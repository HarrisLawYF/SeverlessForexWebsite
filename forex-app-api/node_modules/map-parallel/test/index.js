"use strict";

const chai = require("chai");
const should = chai.should();

const os = require("os");
const mapParallel = require("../index.js");

// creates Array in range, i.e [10, 11, 12, 13, 14, 15]
const _getRangeArr = (min, max) => {
  let arr = [];
  for (var i = 0; i <= max - min; i++) {
    arr.push(min + i);
  }

  return arr;
}

describe("Chunkification", () => {
  it("should tesselate an Array to 4 equal chunks", () => {
    const result = mapParallel._chunkify([1, 2, 3, 4, 5], 4);
    result.should.be.an("Array");
    result.length.should.equal(4);
    result.should.deep.equal([ [ 1, 2 ], [ 3 ], [ 4 ], [ 5 ] ]);
  });

  it("should return an empty array if given an empty Array", () => {
    const result = mapParallel._chunkify([], 4);
    result.should.be.an("Array");
    result.length.should.equal(0);
  });

  it("should throw an exception if given a non-Array input", () => {
    chai.expect(() => mapParallel._chunkify("lala", 1))
    .to.throw("Expected an Array")
  });
});

describe("Mapping in Parallel", () => {
  // Create 2 arrays with numbers that intersect on number `2000`. Then
  // check the intersection to evaluate if result was correct
  const hugeArr = _getRangeArr(2000, 3000);
  const hugeBaseArr = _getRangeArr(0, 2000);

  it("should map parallelly an Array against a Base Array", () => {
    return mapParallel.map(hugeArr, os.cpus().length, (item, base) => {
      return {
        item: item,
        included: base.includes(item)
      }
    }, hugeBaseArr).then((result) => {
      result.should.be.an("Array");

      const intersection = {
        out: result.find((item) => item.item === 2001),
        in: result.find((item) => item.item === 2000)
      }

      Object.keys(intersection).forEach((key) => {
        intersection[key].should.be.an("Object");

        intersection[key].should.have.property("item");
        intersection[key].should.have.property("included");

        intersection[key].item.should.be.a("Number");
        intersection[key].included.should.be.a("Boolean");

        if (key === "out") {
          intersection[key].included.should.equal(false);
        } else {
          intersection[key].included.should.equal(true);
        }
      })
    })
  });

  it("should reject with the error if the function body throws an exception", () => {
    return mapParallel.map(hugeArr, os.cpus().length, (item, base) => {
      return {
        item: itemx, // itemx is `undefined`
        included: base.includes(item)
      }
    }, hugeBaseArr).catch((err) => {
      err.should.be.an("Error");
      err.toString().should.equal("Error: itemx is not defined");
    })
  });
});
